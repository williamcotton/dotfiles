#!/usr/bin/env python3

# ### plt - a command line tool for plotting data
#
# ## example usage
#
# ```shell
# $ cat data.csv | plt "insertions, date { line 1px solid red }" | imgcat --width=100
# $ cat data.csv | plt "deletions, date { bar 20px solid green }" | imgcat --width=100
# $ cat data.csv | plt "[insertions, deletions], date { stackbar 20px [solid orange, solid blue]}" > chart.png
#
# $ plt "insertions, date { line 5px solid red } deletions, date { bar 20px solid #DDFF21 }" < data.csv > combined.png
#
# $ plt "insertions, date { line 5px solid red } deletions, date { bar 20px solid #DDFF21 }" --py > combined.py
# $ cat data.csv | python3 combined.py > combined.png
# ```
#
# ## grammar
#
# ```ebnf
# program = command | command command;
# command = fields "{" display "}";
# fields = FIELDNAME "," FIELDNAME | "[" FIELDNAME "," FIELDNAME "]" "," FIELDNAME;
# display = "line" style | "bar" style | "stackbar" stackbar_style;
# style = WIDTH DRAW_STYLE COLOR;
# stackbar_style = WIDTH "[" DRAW_STYLE COLOR "," DRAW_STYLE COLOR "]";
# FIELDNAME = [a-zA-Z0-9_]+;
# WIDTH = [0-9]+ "px";
# DRAW_STYLE = "solid" | "dashed" | "dotted";
# COLOR = "red" | "green" | "blue" | "orange" | "#" [0-9a-fA-F]{6};
# ```

import os
import tempfile
import subprocess
import sys
from ply import lex, yacc
import argparse

# Define the parser for the plt language
plt_parser = argparse.ArgumentParser(add_help=False)
plt_parser.add_argument('plt', nargs='?', type=str, help='The plt language string')

# Parse the command line arguments
parser = argparse.ArgumentParser(parents=[plt_parser])
parser.add_argument('--py', action='store_true', help='Print the generated Python code and exit')
parser.add_argument('args', nargs='*', type=str, help='Optional arguments')
args = parser.parse_args()


# Define the reserved words
reserved = {
    'line': 'LINE',
    'bar': 'BAR',
    'stackbar': 'STACKBAR',
    'solid': 'DRAW_STYLE',
    'dashed': 'DRAW_STYLE',
    'dotted': 'DRAW_STYLE',
    'red': 'COLOR',
    'green': 'COLOR',
    'blue': 'COLOR',
    'orange': 'COLOR',    
}

# Define the lexer tokens
tokens = (
    'FIELDNAME',
    'WIDTH',
) + tuple(set(reserved.values()))

# Define the lexer rules
t_WIDTH = r'\d+px'
t_COLOR = r'(red|green|blue|orange|\#\w{6})'
t_DRAW_STYLE = r'(solid|dashed|dotted)'

def t_FIELDNAME(t):
    r'[a-zA-Z_][a-zA-Z0-9_]*' # field names must start with a letter or underscore
    t.type = reserved.get(t.value, 'FIELDNAME') # Check for reserved words
    return t

t_ignore  = ' \t\n' # ignore whitespace and newlines

def t_error(t):
    print("Unknown token:", t.value)
    t.lexer.skip(1)

literals = ['[', ']', '{', '}', ',']

# Matplotlib commands
commands = []
command = {}

# Define the parser rules
def p_program(p):
    '''program : command
               | command command'''
    pass

def p_command(p):
    '''command : fields '{' display '}' '''
    commands.append(command.copy())
    pass

def p_fields(p):
    '''fields : FIELDNAME ',' FIELDNAME
              | '[' FIELDNAME ',' FIELDNAME ']' ',' FIELDNAME'''
    command.update({'x_fieldname': p[1], 'y_fieldname': p[3]})
    pass

def p_display(p):
    '''display : LINE style
               | BAR style
               | STACKBAR stackbar_style'''
    command.update({'plot_style': p[1]})
    pass

def p_style(p):
    '''style : WIDTH DRAW_STYLE COLOR'''
    command.update({'width': int(p[1][:-2]), 'draw_style': p[2], 'color': p[3]})
    pass

def p_stackbar_style(p):
    '''stackbar_style : WIDTH '[' DRAW_STYLE COLOR ',' DRAW_STYLE COLOR ']' '''
    pass

def p_error(p):
    print("Syntax error in input:", p)

# Build the lexer and parser
lexer = lex.lex()
parser = yacc.yacc()

# Check if the plt language string is provided
if args.plt:
    # Parse the plt language string using the lexer and parser
    parser = yacc.yacc()
    # A single pass compiler builds the matplotlib commands as we parse the plt language string
    parser.parse(args.plt)

# Compile the matplotlib commands into Python code
output = """#!/usr/bin/env python3

import csv
import sys
import io
import matplotlib.pyplot as plt

# Read CSV or TSV from STDIN
input_file = io.StringIO(sys.stdin.read())
first_line = input_file.readline()
input_file.seek(0)

if '\\t' in first_line:
    # The input data is tab-delimited
    reader = csv.DictReader(input_file, delimiter='\\t')
else:
    # The input data is comma-delimited
    reader = csv.DictReader(input_file)

data = {k: [] for k in reader.fieldnames}
for row in reader:
    for k, v in row.items():
        data[k].append(v)

# Generate the plot
fig, ax = plt.subplots(figsize=(8, 5))
"""
# Iterate over the commands array and create the respective plot types
for command in commands:
    output += f"\n\n# {command['plot_style']} plot for [{command['x_fieldname']}, {command['y_fieldname']}]"
    output += f"\n\nx_value = [float(x) for x in data['{command['x_fieldname']}']]"
    output += f"\ny_value = data['{command['y_fieldname']}']"
    color = command['color']
    width = command['width']
    if command['plot_style'] == 'line':
        output += f"\nax.plot(y_value, x_value, color='{color}', linewidth={width})"
    elif command['plot_style'] == 'bar':
        output += f"\nax.bar(y_value, x_value, color='{color}', width={width / 50}, alpha=0.5)"

# Update the legend names and labels
output += f"""\n
legend_names = {[command['x_fieldname'].capitalize() for command in commands]}
ax.legend(legend_names)

# Replace underscores and dashes with spaces, and capitalize the first letter of each word
x_label = "{commands[0]['y_fieldname']}".replace('_', ' ').replace('-', ' ').title()

ax.set_xlabel(x_label)
ax.set_ylabel('Count')

plt.xticks(rotation=90)
fig.subplots_adjust(bottom=0.2)

# Save the plot to stdout as a PNG image
plt.savefig(sys.stdout.buffer, format='png')"""

# Print the generated Python code and exit if the --py flag is used
if args.py:
    print(output)
    sys.exit()

# Save the plot to a temporary file
with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
    f.write(output)
    temp_file = f.name

# Execute the temporary file using subprocess.run()
subprocess.run(['python3', temp_file], stdin=sys.stdin, stdout=sys.stdout)

# Delete the temporary file
os.unlink(temp_file)
