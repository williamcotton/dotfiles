#!/usr/bin/env python3

# # plt - a command line tool for plotting data
#
# ## example usage
#
# ```shell
# $ cat data.csv | plt "insertions, date { plot 1px solid red }" | imgcat --width=100
# $ cat data.csv | plt "deletions, date { bar 20px solid green }" | imgcat --width=100
# $ cat data.csv | plt "[insertions, deletions], date { stackbar 20px [solid orange, solid blue]}" > chart.png
#
# $ plt "insertions, date { plot 5px solid red } deletions, date { bar 20px solid #DDFF21 }" < data.csv > combined.png
#
# $ plt "insertions, date { plot 5px solid red } deletions, date { bar 20px solid #D3F }" --py > combined.py
# $ cat data.csv | python3 combined.py > combined.png
# ```
#
# ## grammar
#
# ```ebnf
# program = command*;
# command = fields "{" display "}";
# fields = FIELDNAME "," FIELDNAME* | "[" FIELDNAME "," FIELDNAME* "]" "," FIELDNAME;
# display = "plot" style | "bar" style | "stackbar" multi_style;
# style = WIDTH DRAW_STYLE COLOR;
# multi_style = WIDTH "[" DRAW_STYLE COLOR "," DRAW_STYLE COLOR "]";
# FIELDNAME = [a-zA-Z0-9_]+;
# WIDTH = [0-9]+ "px";
# DRAW_STYLE = "solid" | "dashed" | "dotted";
# COLOR = "red" | "green" | "blue" | "orange" | "black" | "yellow" | "#" [0-9a-fA-F]{6} | "#" [0-9a-fA-F]{3};
# ```

import os
import tempfile
import subprocess
import sys
import re
from ply import lex, yacc
import argparse
import pprint
import sourcetypes
from jinja2 import Environment, DictLoader
from collections import OrderedDict
from PIL import Image, ImageDraw, ImageFont
from io import BytesIO

#
# COMMAND LINE INTERFACE
#

# Define the parser for the plt language
plt_parser = argparse.ArgumentParser(add_help=False)
plt_parser.add_argument("plt", nargs="?", type=str, help="The plt language string")

# Parse the command line arguments
parser = argparse.ArgumentParser(parents=[plt_parser])
parser.add_argument(
    "--py", action="store_true", help="Print the generated Python code and exit"
)
parser.add_argument("--debug", action="store_true", help="Print commands and exit")
args = parser.parse_args()

#
# ERROR IMAGE
#

# Create a new image with a transparent background
error_image = Image.new("RGBA", (1000, 40), (0, 0, 0, 0))

# Draw a red line on the image
draw = ImageDraw.Draw(error_image)
draw.line((0, 20, 400, 20), fill="red", width=1)
draw.line((600, 20, 1000, 20), fill="red", width=1)

# Add the text "Syntax Error" in the middle of the red bar
font_path = "/System/Library/Fonts/SFNS.ttf"
font = ImageFont.truetype(font_path, 25)
bbox = font.getbbox("Syntax Error")
text_width = bbox[2] - bbox[0]
text_height = bbox[3] - bbox[1]
text_x = (1000 - text_width) // 2
text_y = (30 - text_height) // 2
draw.text((text_x, text_y), "Syntax Error", font=font, fill="red")

# Save the image to a buffer
error_image_buffer = BytesIO()
error_image.save(error_image_buffer, format="PNG")


#
# INTERMEDIARY DATA STRUCTURES
#

# Matplotlib commands
matplotlib_commands = []

# Legend names
legend_names = []

#
# LANGUAGE DEFINITION
#

color_names = ["red", "green", "blue", "orange", "yellow", "black"]
draw_styles = ["solid", "dashed", "dotted"]

# Define the reserved words
reserved = {"plot": "PLOT", "bar": "BAR", "stackbar": "STACKBAR", "highlight": "HIGHLIGHT"}

reserved.update({color: "COLOR" for color in color_names})
reserved.update({draw_style: "DRAW_STYLE" for draw_style in draw_styles})

# Define the lexer tokens
tokens = (
    "FIELDNAME",
    "WIDTH",
    "INTEGER",
) + tuple(set(reserved.values()))

# Define the lexer rules
draw_styles_regex = "|".join(draw_styles)
t_DRAW_STYLE = f"({draw_styles_regex})"

color_names_regex = "|".join(color_names)
hex_color_regex = r"\#\w{6}|\#\w{3}"
t_COLOR = f"({color_names_regex}|{hex_color_regex})"

t_WIDTH = r"\d+px"

t_INTEGER = r"\d+"

def t_FIELDNAME(t):
    r"[a-zA-Z_][a-zA-Z0-9_\/]*"  # field names must start with a letter or underscore
    t.type = reserved.get(t.value, "FIELDNAME")  # Check for reserved words
    return t


t_ignore = " \t\n"  # ignore whitespace and newlines


def t_error(t):
    print("Unknown token:", t.value)
    t.lexer.skip(1)


literals = ["[", "]", "{", "}", ","]


# Define the parser rules
def p_program(p):
    """program : command
    | program command"""
    pass

command = {}
def p_command(p):
    """command : fields '{' display '}'"""
    command["plot_style_title"] = command['plot_style'].replace('_', ' ').replace('-', ' ').title()
    if "y_fieldnames" in command:
        command["fields_title"] = f"[{command['y_fieldnames']}, {command['x_fieldname']}]"
        legend_names.extend([
            field.replace("_", " ").replace("-", " ").title()
            for field in command["y_fieldnames"]
        ])
        del command["y_fieldname"]
    else:
        command["fields_title"] = f"[{command['y_fieldname']}, {command['x_fieldname']}]"
        legend_names.append(
            command['y_fieldname'].replace("_", " ").replace("-", " ").title()
        )
    matplotlib_commands.append(command.copy())
    command.clear()
    pass


def p_fields(p):
    """fields : FIELDNAME ',' FIELDNAME
    | fields ',' FIELDNAME
    | '[' fields ']' ',' FIELDNAME"""
    if p[1] == "[":
        command.update({"multi": True, "y_fieldnames": p[2], "x_fieldname": p[5]})
    else:
        if isinstance(p[1], list):
            command.update({"y_fieldnames": p[1], "x_fieldname": p[3]})
        else:
            command.update({"y_fieldname": p[1], "x_fieldname": p[3]})
    if not isinstance(p[1], list):
        p[0] = [p[1], p[3]]
    else:
        p[0] = p[1] + [p[3]]
    pass


def p_display(p):
    """display : PLOT WIDTH style
    | BAR WIDTH style
    | BAR WIDTH '[' multi_style ']'
    | STACKBAR WIDTH '[' multi_style ']'
    | HIGHLIGHT INTEGER INTEGER style"""
    multi = True if p[3] == "[" else False
    plot_template_prefix = p[1]
    if multi:
        plot_template_prefix = "multi_" + plot_template_prefix
    template_name = plot_template_prefix + "_template.py"
    command.update({"plot_style": p[1], "template_name": template_name})
    if p[1] == "highlight":
        command.update({"start": int(p[2]), "end": int(p[3])})
    else:
        command.update({ "width": int(p[2][:-2]) })
    pass


def p_style(p):
    """style : DRAW_STYLE COLOR"""
    command.update({"draw_style": p[1], "color": p[2]})
    pass


def p_multi_style(p):
    """multi_style : DRAW_STYLE COLOR ',' DRAW_STYLE COLOR
    | multi_style ',' DRAW_STYLE COLOR"""
    if len(p) == 5:
        p[1] += [{"draw_style": p[3], "color": p[4]}]
        command.update({"styles": p[1]})
    if len(p) == 6:
        command.update(
            {
                "styles": [
                    {"draw_style": p[1], "color": p[2]},
                    {"draw_style": p[4], "color": p[5]},
                ]
            }
        )
    if not isinstance(p[1], list):
        p[0] = [
            {"draw_style": p[1], "color": p[2]},
            {"draw_style": p[4], "color": p[5]},
        ]
    else:
        p[0] = p[1] + [{"draw_style": p[3], "color": p[4]}]

    pass

def underline_error(code, p):
    # Get the token value and position
    token_value = p.value
    token_pos = p.lexpos

    # Search for the token in the code
    match = re.search(re.escape(token_value), code[token_pos:])
    if match:
        start_index = token_pos + match.start()
        end_index = token_pos + match.end()

        # Split the code into lines
        lines = code.split("\n")

        # Find the line number of the token
        line_number = 1
        for i, line in enumerate(lines):
            if start_index >= len(line):
                start_index -= len(line) + 1
                end_index -= len(line) + 1
                line_number += 1
            else:
                break

        # Underline the token in red
        line = lines[line_number - 1]
        underline = line[:start_index] + "\033[91m" + "\033[4m" + token_value + "\033[0m" + "\033[0m" + line[end_index:]
        lines[line_number - 1] = underline

        # Print the code with the underlined token and the entire line
        return "\n".join(lines) + "\n"
    else:
        return "Error: could not find token '{}' in code".format(token_value)

def p_error(p):
    sys.stderr.write("\n" + underline_error(args.plt, p) + "\n")
    sys.stdout.buffer.write(error_image_buffer.getvalue())
    exit(1)


# Build the lexer and parser
lexer = lex.lex()
parser = yacc.yacc()

#
# PARSE FOR INTERMEDIARY DATA
#

# Check if the plt language string is provided
if args.plt:
    # Parse the plt language string using the lexer and parser
    parser = yacc.yacc()
    # A single pass compiler builds the matplotlib commands as we parse the plt language string
    parser.parse(args.plt)
    # Make unique legend names
    legend_names = list(OrderedDict.fromkeys(legend_names))

#
# DEBUGGING
#

# Print the commands and exit if the --debug flag is used
if args.debug:
    print("\n\033[4mTokens\033[0m\n")
    lexer.input(args.plt)
    for tok in lexer:
        print(tok)
    print("\n\033[4mCommands\033[0m\n")
    for command in matplotlib_commands:
        pprint.pprint(command)
        print()
    sys.exit()

#
# PYTHON CODE GENERATION
#

## template.py ################################################################
template_str: sourcetypes.python = """#!/usr/bin/env python3

import csv
import sys
import io
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.transforms as transforms
import numpy as np

# Read CSV or TSV from STDIN
input_file = io.StringIO(sys.stdin.read())
first_line = input_file.readline()
input_file.seek(0)

if '\\t' in first_line:
    # The input data is tab-delimited
    reader = csv.DictReader(input_file, delimiter='\\t')
else:
    # The input data is comma-delimited
    reader = csv.DictReader(input_file)

data = {k: [] for k in reader.fieldnames}
for row in reader:
    for k, v in row.items():
        data[k].append(v)

# Generate the plot
fig, ax = plt.subplots(figsize=(8, 5))

{%- for command in matplotlib_commands %}

### {{ command['plot_style_title'] }}: {{ command['fields_title'] }}
x_value = data['{{ command['x_fieldname'] }}']
x = np.arange(len(x_value))
ax.set_xticks(x, x_value)
{%- include command['template_name'] %}
{%- endfor %}

# Update the legend names and labels
ax.legend({{legend_names}})

# Set the x-axis labels
ax.set_xlabel('{{ matplotlib_commands[0]['x_fieldname'].replace('_', ' ').replace('-', ' ').title() }}')
plt.xticks(rotation=90)

# Set the y-axis label
ax.set_ylabel('Count')

# Add space for the x-axis labels
fig.subplots_adjust(bottom=0.2)
# Save the plot to stdout as a PNG image
plt.savefig(sys.stdout.buffer, format='png')
"""

### plot_template.py ##########################################################
plot_template_str: sourcetypes.python = """
y_{{ command['y_fieldname'] }}_value = [float(y) for y in data['{{ command['y_fieldname'] }}']]
width = 0.02
ax.plot(x_value, y_{{ command['y_fieldname'] }}_value, color='{{ command['color'] }}', linewidth={{ command['width'] }})
"""

### bar_template.py ###########################################################
bar_template_str: sourcetypes.python = """
y_{{ command['y_fieldname'] }}_value = [float(y) for y in data['{{ command['y_fieldname'] }}']]
width = 0.02
ax.bar(x_value, y_{{ command['y_fieldname'] }}_value, color='{{ command['color'] }}', width={{ command['width'] / 50 }}, alpha=0.5)
"""

## multi_bar_template.py ######################################################
multi_bar_template_str: sourcetypes.python = """
y_values = [np.array([float(y) for y in data[field]]) for field in {{ command['y_fieldnames'] }}]
styles = {{ command['styles'] }}
width = {{ command['width'] / 50 }}
ax.set_xticks(x + width, x_value)
multiplier = 0
for index, field in enumerate({{ command['y_fieldnames'] }}):
    offset = width * multiplier
    rects = ax.bar(x + offset, y_values[index], width, color=styles[index]['color'], linewidth=1)
    multiplier += 1
"""

## multi_stackbar_template.py #################################################
multi_stackbar_template_str: sourcetypes.python = """
y_values = [np.array([float(y) for y in data[field]]) for field in {{ command['y_fieldnames'] }}]
styles = {{ command['styles'] }}
width = {{ command['width'] / 50 }}
bottom = np.zeros(3)
for index, field in enumerate({{ command['y_fieldnames'] }}):
    rects = ax.bar(x_value, y_values[index], width, color=styles[index]['color'], bottom=bottom)
    bottom += y_values[index]
"""

## highlight_template.py ######################################################
highlight_template_str: sourcetypes.python = """
trans = transforms.blended_transform_factory(ax.transData, ax.transAxes)
rect = mpatches.Rectangle(({{ command['start'] }}, 0), width={{ command['end'] - command['start'] }}, height=1, transform=trans, color='{{ command['color'] }}', alpha=0.5)
ax.add_patch(rect)
"""
###############################################################################

# Create a dictionary with the template string and name
templates = {
    "template.py": template_str,
    "plot_template.py": plot_template_str,
    "bar_template.py": bar_template_str,
    "multi_bar_template.py": multi_bar_template_str,
    "multi_stackbar_template.py": multi_stackbar_template_str,
    "highlight_template.py": highlight_template_str,
}

# Create a Jinja environment with the DictLoader
env = Environment(loader=DictLoader(templates))

# Render the template with the data
output = env.get_template("template.py").render(
    matplotlib_commands=matplotlib_commands, 
    legend_names=legend_names,
)

#
# PRINT PYTHON CODE WITH TEXT OUTPUT
#

# Print the generated Python code and exit if the --py flag is used
if args.py:
    print(output)
    sys.exit()

#
# EXECUTE PYTHON CODE WITH PNG OUTPUT
#

# Save the plot to a temporary file
with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
    f.write(output)
    temp_file = f.name

# Execute the temporary file using subprocess.run()
subprocess.run(["python3", temp_file], stdin=sys.stdin, stdout=sys.stdout)

# Delete the temporary file
os.unlink(temp_file)
