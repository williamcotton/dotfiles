function hawk() {
  awk -f hawk
}

# Create a new directory and enter it
function md() {
	mkdir -p "$@" && cd "$@"
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

# Create a data URL from an image (works for other file types too, if you tweak the Content-Type afterwards)
dataurl() {
	echo "data:image/${1##*.};base64,$(openssl base64 -in "$1")" | tr -d '\n'
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
    local port="${1:-8000}"
    PYTHONIOENCODING=utf-8 python -m http.server &
    sleep 0.1
    open "http://localhost:${port}/"
    fg
}

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
function httpcompression() {
	encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# Gzip-enabled `curl`
function gurl() {
	curl -sH "Accept-Encoding: gzip" "$@" | gunzip
}

# Syntax-highlight JSON strings or files
function json() {
	if [ -p /dev/stdin ]; then
		# piping, e.g. `echo '{"foo":42}' | json`
		python -mjson.tool | pygmentize -l javascript
	else
		# e.g. `json '{"foo":42}'`
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	fi
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	echo # newline
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	echo # newline
}

# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	echo # newline
}

# Open a tx on blocktrail
function txi() {
	open "https://www.blocktrail.com/tBTC/tx/$@"
}

function adi() {
	open "https://www.blocktrail.com/tBTC/address/$@"
}

# check out branch WMW-4324
cob() {
 git branch -a | grep "$1" | sed -n 1p | xargs git checkout;
}

# dup so that vscode works
update_terminal_cwd() {
    # Identify the directory using a "file:" scheme URL,
    # including the host name to disambiguate local vs.
    # remote connections. Percent-escape spaces.
    local SEARCH=' '
    local REPLACE='%20'
    local PWD_URL="file://$HOSTNAME${PWD//$SEARCH/$REPLACE}"
    printf '\e]7;%s\a' "$PWD_URL"
}

function killa() {
  # Check if an argument was provided
  if [ -z "$1" ]; then
    echo "Usage: killa <process name>"
    return 1
  fi

  # Get the PID of the process
  pid=$(ps aux | grep "$1" | grep -v grep | awk '{print $2}')

  # Check if a PID was found
  if [ -z "$pid" ]; then
    echo "No process found with name: $1"
    return 1
  fi

  # Kill the process
  kill -9 "$pid"
  echo "Killed process with PID: $pid"
}

set_project_name() {
  local dir=$(pwd)
  while [ "$dir" != "/" ]; do
    if [[ "$dir" =~ ^(.*/)?Projects/([^/]+)/?$ ]]; then
      export PRJ_NAME="${match[2]}"
      export PRJ_DIR="$HOME/Projects/${match[2]}"
      return
    fi
    dir=$(dirname "$dir")
  done
}
set_project_name

get_project_name() { echo "$PRJ_NAME" }

get_project_database_name() {
  local project_name=$(get_project_name)
  local db_file="$HOME/Projects/${project_name}/.db"
  if [ -f "$db_file" ]; then
    local db_name=$(grep -o 'NAME=[^[:space:]]*' "$db_file" | cut -d= -f2)
    if [ -n "$db_name" ]; then
      echo "$db_name"
      return
    fi
  fi
  echo "$project_name" | sed 's/-/_/g'
}

mysql_project_database() {
  local project_database_name=$(get_project_database_name)
  mysql -u root "$project_database_name" "$@"
}

alias mpd='mysql_project_database'

get_last_command() {
  local last_command=$(lastsql $1)
  echo "$last_command"
}

sc() {
  local scratch_file="$HOME/Projects/$(get_project_name)/scratch.sql"
  local last_command=$(get_last_command "$scratch_file")
  echo "$last_command" >&2
  mysql_project_database -e "$last_command" | ascii-table
}

sl() {
  local last_command=$(get_last_command "$1")
  mysql_project_database -e "$last_command"
}

slx() {
  local scratch_file="/dev/stdin"
  local output_file="/dev/stdout"
  local execute_all=false

  while getopts "i:o:a" opt; do
    case $opt in
      i)
        scratch_file="$OPTARG"
        ;;
      o)
        output_file="$OPTARG"
        ;;
      a)
        execute_all=true
        ;;
      \?)
        echo "Invalid option: -$OPTARG" >&2
        return 1
        ;;
    esac
  done

  shift $((OPTIND-1))

  if [ $# -gt 0 ]; then
    echo "Invalid argument: $1" >&2
    return 1
  fi

  if $execute_all; then
    mysql_project_database < "$scratch_file" | tsvtoxlsx > "$output_file"
  else
    local last_command=$(get_last_command "$scratch_file")
    mysql_project_database -e "$last_command" | tsvtoxlsx > "$output_file"
  fi
}

prj() {
  local dir=$(pwd)
  while [ "$dir" != "/" ]; do
    if [[ "$dir" =~ ^(.*/)?Projects/([^/]+)/?$ ]]; then
      local project_name=${match[2]}
      echo "[$project_name]\n" >&2
      cd "$dir"
			echo "$project_name" >> "$HOME/.prj_history"
      export PRJ_HISTORY="$project_name"
      echo "$(mdless --no-pager todo.md)" >&2
      return
    fi
    dir=$(dirname "$dir")
  done
  local last_project=${PRJ_HISTORY:-$(tail -n 1 "$HOME/.prj_history" 2>/dev/null)}
  if [ -n "$last_project" ]; then
    echo "[last project]" >&2
    echo "[$last_project]\n" >&2
    cd "$HOME/Projects/$last_project"
    export PRJ_HISTORY="$last_project"
    echo "$(mdless --no-pager todo.md)" >&2
  else
    echo "Error: Could not find project root directory and no project found in history" >&2
  fi
}

alias chrome="/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome"

ss() {
  local url=$1
  if [[ ! "$url" =~ ^https?:// ]]; then
    url="https://$url"
  fi
  local filename="Chrome Screenshot $(date '+%Y-%m-%d at %I.%M.%S %p').png"
  local filepath="$HOME/Desktop/$filename"
  chrome --headless --disable-gpu --window-size=1920,1080 --screenshot="$filepath" "$url" && imgcat --width $(tput cols) "$filepath" && impbcopy "$filepath"
}

htmltopng() {
  local width=640
  local height=480
  while getopts "w:h:" opt; do
    case $opt in
      w) width=$OPTARG ;;
      h) height=$OPTARG ;;
      *) return 1 ;;
    esac
  done
  shift $((OPTIND - 1))

  local html
  if [ -t 0 ]; then
    html=$1
  else
    html=$(cat)
  fi
  local filename="Chrome Screenshot $(date '+%Y-%m-%d at %I.%M.%S %p').png"
  local filepath="$HOME/Desktop/$filename"
  local datauri="data:text/html;base64,$(echo "$html" | base64)"
  chrome --headless --disable-gpu --disable-extensions --window-size="$width,$height" --screenshot="$filepath" "$datauri"
  sleep 1
  cat "$filepath"
  rm "$filepath"
}

imgc() {
  tee >(imgcat "$@") >(impbcopy -) > /dev/null
}

tc() {
  touch "$@"
  code "$@"
}

htmltopdf() {
  local html
  local size="A4"
  local orientation="portrait"
  while getopts "l" opt; do
    case $opt in
      l)
        size="A4 landscape"
        orientation="landscape"
        ;;
      \?)
        echo "Invalid option: -$OPTARG" >&2
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if [ -t 0 ]; then
    html=$1
  else
    html=$(cat)
  fi

  local filename="HTML to PDF $(date '+%Y-%m-%d at %I.%M.%S %p').pdf"
  local filepath="$HOME/Desktop/$filename"

  # remove chrome headless header and footer
  local css="@media print { @page { margin: 0; size: $size; } body { margin: 1.6cm; } }"
  local datauri="data:text/html;base64,$(echo "<style>$css</style>$html" | base64)"
  chrome --headless --disable-gpu --disable-extensions --print-to-pdf="$filepath" --no-margins "$datauri"
  sleep 1
  cat "$filepath"
  rm "$filepath"
}

prependcss() {
  local html="$(cat -)"
  local css=""
  for css_file in "$@"; do
    css="$css$(cat "$css_file")"
  done
  echo "<style>$css</style>$html"
}

appendjs() {
  local js_file="$1"
  shift
  local argv=("$js_file" "$@")
  local html="$(cat -)"
  local js="$(cat "$js_file")"
  echo "$html<script>const argv = [$(printf '"%s",' "${argv[@]}")]; $js</script>"
}

function prependhtml() {
    local prefix=""
    for arg in "$@"; do
        prefix="$prefix$arg"
    done
    local html="$(cat -)"
    echo "$prefix$html"
}

function csvtosql() {
  sqlite3 -header -csv ':memory:' ".import /dev/stdin csv" "$@" 2>/dev/null
}

function csvtotsv() {
  csvformat -T -
}

function tsvtocsv() {
  awk 'BEGIN { FS="\t"; OFS="," } {
    rebuilt=0
    for(i=1; i<=NF; ++i) {
      if ($i ~ /,/ && $i !~ /^".*"$/) { 
        gsub("\"", "\"\"", $i)
        $i = "\"" $i "\""
        rebuilt=1 
      }
    }
    if (!rebuilt) { $1=$1 }
    print
  }'
}

# Define the adeline function
adeline() {
  # Get a random image file from the ~/Pictures/ada directory
  image_file=$(ls ~/Pictures/ada | shuf -n 1)

  # Display the image using imgcat
  imgcat ~/Pictures/ada/$image_file
}

# Create an alias for the adeline function
alias ada="adeline"

# Define the lawrence function
lawrence() {
  # Get a random image file from the ~/Pictures/ren directory
  image_file=$(ls ~/Pictures/ren | shuf -n 1)

  # Display the image using imgcat
  imgcat ~/Pictures/ren/$image_file
}

# Create an alias for the lawrence function
alias ren="lawrence"
