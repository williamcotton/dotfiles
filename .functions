CURRENT_FILE=${(%):-%N}

# Get the directory of the current file
DIRECTORY=`dirname $CURRENT_FILE`

. "$DIRECTORY/.project_functions"

function hawk() {
  awk -f "$HOME/dotfiles/bin/hawk"
}

function fawk() {
  gawk -i "$HOME/dotfiles/bin/fawk" "$@"
}

# Create a new directory and enter it
function md() {
	mkdir -p "$@" && cd "$@"
}

function dockerbash() {
  local image="${1:-ubuntu}"
  docker run -it --rm "$image" bash
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
	function diff() {
		git diff --no-index --color-words "$@"
	}
fi

# Create a data URL from an image (works for other file types too, if you tweak the Content-Type afterwards)
dataurl() {
	echo "data:image/${1##*.};base64,$(openssl base64 -in "$1")" | tr -d '\n'
}

# Start an HTTP server from a directory, optionally specifying the port
function server() {
    local port="${1:-8000}"
    PYTHONIOENCODING=utf-8 python -m http.server &
    sleep 0.1
    open "http://localhost:${port}/"
    fg
}

function picko() {
  osascript 3<&0 "$@" <<EOF | tr '\r' '\n'
    on run argv
      set stdin to do shell script "cat 0<&3"
      set options to paragraphs of (stdin)

      tell application "System Events"
        activate
        choose from list options
      end tell
    end run
EOF
}

function sshapp() {
  osascript -e "tell app \"Terminal\"
    set win to do script \"ssh $1\"
    set win's current settings to settings set \"Pro\"
    set number of columns of win to 120
    set number of rows of win to 40
    activate
  end tell"
}

# Test if HTTP compression (RFC 2616 + SDCH) is enabled for a given URL.
# Send a fake UA string for sites that sniff it instead of using the Accept-Encoding header. (Looking at you, ajax.googleapis.com!)
function httpcompression() {
	encoding="$(curl -LIs -H 'User-Agent: Mozilla/5 Gecko' -H 'Accept-Encoding: gzip,deflate,compress,sdch' "$1" | grep '^Content-Encoding:')" && echo "$1 is encoded using ${encoding#* }" || echo "$1 is not using any encoding"
}

# Gzip-enabled `curl`
function gurl() {
	curl -sH "Accept-Encoding: gzip" "$@" | gunzip
}

# Syntax-highlight JSON strings or files
function json() {
	if [ -p /dev/stdin ]; then
		# piping, e.g. `echo '{"foo":42}' | json`
		python -mjson.tool | pygmentize -l javascript
	else
		# e.g. `json '{"foo":42}'`
		python -mjson.tool <<< "$*" | pygmentize -l javascript
	fi
}

# All the dig info
function digga() {
	dig +nocmd "$1" any +multiline +noall +answer
}

# Escape UTF-8 characters into their 3-byte format
function escape() {
	printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
	echo # newline
}

# Decode \x{ABCD}-style Unicode escape sequences
function unidecode() {
	perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
	echo # newline
}

# Get a character’s Unicode code point
function codepoint() {
	perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
	echo # newline
}

unixv() {
  find /usr/share/man -type f -exec grep -q ".At $1" {} \; -exec echo {} \;
}

# check out branch WMW-4324
cob() {
 git branch -a | grep "$1" | sed -n 1p | xargs git checkout;
}

# dup so that vscode works
update_terminal_cwd() {
    # Identify the directory using a "file:" scheme URL,
    # including the host name to disambiguate local vs.
    # remote connections. Percent-escape spaces.
    local SEARCH=' '
    local REPLACE='%20'
    local PWD_URL="file://$HOSTNAME${PWD//$SEARCH/$REPLACE}"
    printf '\e]7;%s\a' "$PWD_URL"
}

function killa() {
  # Check if an argument was provided
  if [ -z "$1" ]; then
    echo "Usage: killa <process name>"
    return 1
  fi

  # Get the PID of the process
  pid=$(ps aux | grep "$1" | grep -v grep | awk '{print $2}')

  # Check if a PID was found
  if [ -z "$pid" ]; then
    echo "No process found with name: $1"
    return 1
  fi

  # Kill the process
  kill -9 "$pid"
  echo "Killed process with PID: $pid"
}

alias chrome="/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome"

ss() {
  local url=$1
  if [[ ! "$url" =~ ^https?:// ]]; then
    url="https://$url"
  fi
  local filename="Chrome Screenshot $(date '+%Y-%m-%d at %I.%M.%S %p').png"
  local filepath="$HOME/Desktop/$filename"
  chrome --headless --disable-gpu --window-size=1920,1080 --screenshot="$filepath" "$url" && imgcat --width $(tput cols) "$filepath" && impbcopy "$filepath"
}

htmltopng() {
  local width=640
  local height=480
  while getopts "w:h:" opt; do
    case $opt in
      w) width=$OPTARG ;;
      h) height=$OPTARG ;;
      *) return 1 ;;
    esac
  done
  shift $((OPTIND - 1))

  local html
  if [ -t 0 ]; then
    html=$1
  else
    html=$(cat)
  fi
  local filename="Chrome Screenshot $(date '+%Y-%m-%d at %I.%M.%S %p').png"
  local filepath="$HOME/Desktop/$filename"
  local datauri="data:text/html;base64,$(echo "$html" | base64)"
  chrome --headless --disable-gpu --disable-extensions --window-size="$width,$height" --screenshot="$filepath" "$datauri"
  sleep 1
  cat "$filepath"
  rm "$filepath"
}

imgc() {
  tee >(imgcat "$@") >(impbcopy -) > /dev/null
}

tc() {
  touch "$@"
  code "$@"
}

tce() {
  tc "$@"
  chmod +x "$@"
}

js () {
  node -e "const u = require('utils'); console.log($1);"
}

xa() {
  local args=()
  for arg in "$@"; do
    args+=("-I" "{}")
  done
  xargs "${args[@]}" "$@"
}

qs() {
  hxnormalize -x | hxselect -c "$@" | hxunent
}

function jqr() {
    echo $(echo $1 | jq -r $2)
}

htmltopdf() {
  local html
  local size="A4"
  local orientation="portrait"
  while getopts "l" opt; do
    case $opt in
      l)
        size="A4 landscape"
        orientation="landscape"
        ;;
      \?)
        echo "Invalid option: -$OPTARG" >&2
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))

  if [ -t 0 ]; then
    html=$1
  else
    html=$(cat)
  fi

  local filename="HTML to PDF $(date '+%Y-%m-%d at %I.%M.%S %p').pdf"
  local filepath="$HOME/Desktop/$filename"

  # remove chrome headless header and footer
  local css="@media print { @page { margin: 0; size: $size; } body { margin: 1.6cm; } }"
  local datauri="data:text/html;base64,$(echo "<style>$css</style>$html" | base64)"
  chrome --headless --disable-gpu --disable-extensions --print-to-pdf="$filepath" --no-margins "$datauri"
  sleep 1
  cat "$filepath"
  rm "$filepath"
}

prependcss() {
  local html="$(cat -)"
  local css=""
  for arg in "$@"; do
    if [[ -f "$arg" ]]; then
      css="$css$(cat "$arg")"
    else
      css="$css$arg"
    fi
  done
  echo "<style>$css</style>$html"
}

hlrow () {
  local row="$1"
  local color="${2:-yellow}"
  local css="tr:nth-child($(($row + 1))) { background-color: $color; }"
  prependcss "$css"
}

function rc {
  # Count the number of lines in the CSV file (excluding the header)
  local count=$(tail -n +2 | wc -l)

  # Output the integer value
  echo "Row count: $count"
}

function rhead {
  # Get the number of rows to display
  local count="${1:-10}"

  # Output the header
  head -n 1

  # Output the specified number of rows, including the first row
  awk -v count="$count" 'NR <= count' 
}

appendjs() {
  local js_file="$1"
  shift
  local argv=("$js_file" "$@")
  local html="$(cat -)"
  local js="$(cat "$js_file")"
  echo "$html<script>const argv = [$(printf '"%s",' "${argv[@]}")]; $js</script>"
}

function prependhtml() {
    local prefix=""
    for arg in "$@"; do
        prefix="$prefix$arg"
    done
    local html="$(cat -)"
    echo "$prefix$html"
}

function csvtosql() {
  sqlite3 -header -csv ':memory:' ".import /dev/stdin csv" "$@" 2>/dev/null
}

function csvtotsv() {
  csvformat -T -
}

function tsvtocsv() {
  awk 'BEGIN { FS="\t"; OFS="," } {
    rebuilt=0
    for(i=1; i<=NF; ++i) {
      if ($i ~ /,/ && $i !~ /^".*"$/) { 
        gsub("\"", "\"\"", $i)
        $i = "\"" $i "\""
        rebuilt=1 
      }
    }
    if (!rebuilt) { $1=$1 }
    print
  }'
}

# Define the adeline function
adeline() {
  # Get a random image file from the ~/Pictures/ada directory
  image_file=$(ls ~/Pictures/ada | shuf -n 1)

  # Display the image using imgcat
  imgcat ~/Pictures/ada/$image_file
}

# Create an alias for the adeline function
alias ada="adeline"

# Define the lawrence function
lawrence() {
  # Get a random image file from the ~/Pictures/ren directory
  image_file=$(ls ~/Pictures/ren | shuf -n 1)

  # Display the image using imgcat
  imgcat ~/Pictures/ren/$image_file
}

# Create an alias for the lawrence function
alias ren="lawrence"

function paths() {
  echo $PATH | awk -F: '{ for (i = 1; i <= NF; i++) print $i }'
}